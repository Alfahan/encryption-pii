// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/dyaksa/sqlx-encrypt/postgres/types"
	"github.com/google/uuid"
)

const fetchProfile = `-- name: FetchProfile :one
SELECT 
    nik, name, phone, email, dob 
FROM 
    profile 
WHERE 
    id = $1
`

type FetchProfileRow struct {
	Nik   types.AEADString
	Name  types.AEADString
	Phone types.AEADString
	Email types.AEADString
	Dob   types.AEADTime
}

// FetchProfile
//
//	SELECT
//	    nik, name, phone, email, dob
//	FROM
//	    profile
//	WHERE
//	    id = $1
func (q *Queries) FetchProfile(ctx context.Context, id uuid.UUID) (FetchProfileRow, error) {
	row := q.db.QueryRowContext(ctx, fetchProfile, id)
	var i FetchProfileRow
	err := row.Scan(
		&i.Nik,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Dob,
	)
	return i, err
}

const findProfilesByName = `-- name: FindProfilesByName :many
SELECT 
    id, nik, name, phone, email, dob 
FROM 
    profile 
WHERE 
   name_bidx = ANY($1)
`

type FindProfilesByNameRow struct {
	ID    uuid.UUID
	Nik   types.AEADString
	Name  types.AEADString
	Phone types.AEADString
	Email types.AEADString
	Dob   types.AEADTime
}

// FindProfilesByName
//
//	SELECT
//	    id, nik, name, phone, email, dob
//	FROM
//	    profile
//	WHERE
//	   name_bidx = ANY($1)
func (q *Queries) FindProfilesByName(ctx context.Context, nameBidx types.BIDXString) ([]FindProfilesByNameRow, error) {
	rows, err := q.db.QueryContext(ctx, findProfilesByName, nameBidx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindProfilesByNameRow
	for rows.Next() {
		var i FindProfilesByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Nik,
			&i.Name,
			&i.Phone,
			&i.Email,
			&i.Dob,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTextHeap = `-- name: FindTextHeap :many
SELECT 
    content 
FROM 
    text_heap 
WHERE 
    type = $1
    AND content LIKE $2 || '%'
`

type FindTextHeapParams struct {
	Type    string
	Content sql.NullString
}

// FindTextHeap
//
//	SELECT
//	    content
//	FROM
//	    text_heap
//	WHERE
//	    type = $1
//	    AND content LIKE $2 || '%'
func (q *Queries) FindTextHeap(ctx context.Context, arg FindTextHeapParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, findTextHeap, arg.Type, arg.Content)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var content string
		if err := rows.Scan(&content); err != nil {
			return nil, err
		}
		items = append(items, content)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const storeProfile = `-- name: StoreProfile :exec
INSERT INTO profile
    (id, nik, nik_bidx, name, name_bidx, phone, phone_bidx, email, email_bidx, dob)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT (id) 
    DO UPDATE SET updated_at = NOW()
`

type StoreProfileParams struct {
	ID        uuid.UUID
	Nik       types.AEADString
	NikBidx   types.BIDXString
	Name      types.AEADString
	NameBidx  types.BIDXString
	Phone     types.AEADString
	PhoneBidx types.BIDXString
	Email     types.AEADString
	EmailBidx types.BIDXString
	Dob       types.AEADTime
}

// StoreProfile
//
//	INSERT INTO profile
//	    (id, nik, nik_bidx, name, name_bidx, phone, phone_bidx, email, email_bidx, dob)
//	VALUES
//	    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
//	ON CONFLICT (id)
//	    DO UPDATE SET updated_at = NOW()
func (q *Queries) StoreProfile(ctx context.Context, arg StoreProfileParams) error {
	_, err := q.db.ExecContext(ctx, storeProfile,
		arg.ID,
		arg.Nik,
		arg.NikBidx,
		arg.Name,
		arg.NameBidx,
		arg.Phone,
		arg.PhoneBidx,
		arg.Email,
		arg.EmailBidx,
		arg.Dob,
	)
	return err
}

const storeTextHeap = `-- name: StoreTextHeap :exec


INSERT INTO text_heap 
	(type, content)
VALUES
	($1, $2)
ON CONFLICT (type, content) 
    DO NOTHING
`

type StoreTextHeapParams struct {
	Type    string
	Content string
}

// https://docs.sqlc.dev/en/latest/howto/named_parameters.html#naming-parameters
//
//	INSERT INTO text_heap
//		(type, content)
//	VALUES
//		($1, $2)
//	ON CONFLICT (type, content)
//	    DO NOTHING
func (q *Queries) StoreTextHeap(ctx context.Context, arg StoreTextHeapParams) error {
	_, err := q.db.ExecContext(ctx, storeTextHeap, arg.Type, arg.Content)
	return err
}
